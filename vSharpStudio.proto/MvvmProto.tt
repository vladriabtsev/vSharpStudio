<#@ template debug="true" hostspecific="True" language="C#" #>
<#@ assembly name="System.Core.dll" #>
<#@ assembly name="EnvDTE" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#
		//IServiceProvider serviceProvider = (IServiceProvider)this.Host;
		//EnvDTE.DTE dte = (EnvDTE.DTE) serviceProvider.GetCOMService(typeof(EnvDTE.DTE));
var path = this.Host.ResolvePath(".");
path = path.Substring(0, path.Length - 1); //MvvmProto.cs");
  // https://docs.microsoft.com/en-us/visualstudio/modeling/design-time-code-generation-by-using-t4-text-templates?view=vs-2017
var lst = GetProtoClassDescs(path+@"bin\Debug\netstandard2.0\vSharpStudio.proto.dll", "Proto.Config", true);
#>
using System;
using System.Collections.Generic;
using System.Text;

namespace vSharpStudio.vm.ViewModels
{
<# foreach(var t in lst) { #>
	public class <#= t.Name #>
	{
<# foreach(var tt in t.ListProperties) { #>
		public <#= tt.TypeName #> <#= tt.Name #> { get { return _<#= tt.Name #>; } set { SetValue<<#= tt.TypeName #>>(ref _<#= tt.Name #>, value, t => { On<#= tt.Name #>Changed(); }); } }
		private <#= tt.TypeName #> _<#= tt.Name #>;
		partial On<#= tt.Name #>Changed();
<# } #>
	}
<# } #>
}
<#+

  [Serializable]
  public class ClassDesc
  {
    public ClassDesc()
    {
      ListProperties = new List<PropertyDesc>();
    }
    public string Name;
    public string TypeNamespace;
    public List<PropertyDesc> ListProperties;
  }
  [Serializable]
  public class PropertyDesc
  {
    public string Name;
    public string TypeName;
    public string TypeNamespace;

    public bool IsComplex;
    public bool IsEnum;
    public bool IsList;
  }

    private static Dictionary<string, DateTime> _dicAsmUpdate = new Dictionary<string, DateTime>();
    private static Dictionary<string, List<ClassDesc>> _dicClassDesc = new Dictionary<string, List<ClassDesc>>();
  // asmpath relative to project path
    public static List<ClassDesc> GetProtoClassDescs(string asmpath, string nmspace, bool isReload = false)
    {
		//var asmpath = GetProjectPath() + asmrelpath;

      List<ClassDesc> res = null;
      if (!_dicAsmUpdate.ContainsKey(asmpath))
        _dicAsmUpdate[asmpath] = DateTime.Now.AddYears(-10);
      var file = new FileInfo(asmpath);
      if (isReload || _dicAsmUpdate[asmpath] < file.LastWriteTimeUtc)
      {
        var source = File.ReadAllBytes(asmpath);
        var asm = Assembly.Load(source);
        _dicAsmUpdate[asmpath] = file.LastWriteTimeUtc;
        res = new List<ClassDesc>();
        var types = asm.GetTypes().Where(t => t.Namespace == nmspace && t.IsPublic).OrderBy(n => n.Name);
        foreach (var t in types)
        {
          var cd = new ClassDesc();
          cd.Name = t.Name;
          cd.TypeNamespace = t.Namespace;
          res.Add(cd);
          var properties = t.GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly).OrderBy(n => n.Name);
          foreach (var tt in properties)
          {
            //if (tt.PropertyType.Name == "MessageDescriptor")
            //  continue;
            var p = new PropertyDesc();
            p.Name = tt.Name;
            switch (tt.PropertyType.Name)
            {
              case "int":
              case "long":
              case "float":
              case "double":
              case "decimal":
              case "string":
                p.TypeName = tt.PropertyType.Name;
                break;
              case "Int32":
                p.TypeName = "int";
                break;
              case "Bool":
              case "String":
              case "Decimal":
                p.TypeName = tt.PropertyType.Name.ToLower();
                break;
              default:
                if (tt.PropertyType.Name.StartsWith("List"))
                  p.IsList = true;
                p.IsComplex = true;
                break;
            }
            cd.ListProperties.Add(p);
          }
        }
        _dicClassDesc[asmpath] = res;
      }
      res = _dicClassDesc[asmpath];
      return res;
    }
/*
public static EnvDTE.Project GetCurrentProject()  {

    IServiceProvider _ServiceProvider = (IServiceProvider)Host;
    if (_ServiceProvider == null)
        throw new Exception("Host property returned unexpected value (null)");
	
    EnvDTE.DTE dte = (EnvDTE.DTE)_ServiceProvider.GetService(typeof(EnvDTE.DTE));
    if (dte == null)
        throw new Exception("Unable to retrieve EnvDTE.DTE");
	
    Array activeSolutionProjects = (Array)dte.ActiveSolutionProjects;
    if (activeSolutionProjects == null)
        throw new Exception("DTE.ActiveSolutionProjects returned null");
	
    EnvDTE.Project dteProject = (EnvDTE.Project)activeSolutionProjects.GetValue(0);
    if (dteProject == null)
        throw new Exception("DTE.ActiveSolutionProjects[0] returned null");
	
    return dteProject;
}

private static string GetProjectPath()
{
    EnvDTE.Project project = GetCurrentProject();
    System.IO.FileInfo info = new System.IO.FileInfo(project.FullName);
    return info.Directory.FullName;
}*/

#>