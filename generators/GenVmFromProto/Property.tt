<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="vSharpStudio.common" #>

<#= this.Doc.Comments #><#= this.Doc.Attributes #>public <#=PropType#> <#=FieldName#> // <#=t4.FilePos() #>
{ 
    get { return this._<#=FieldName#>; }
    set
    {
        // Use 'On<#=FieldName#>Changing' to change 'value' before setting property. It is a patial method and expected will be implemented not often.
<#   if (this.DocMes.IsBindableBase && this.isSetPropertyByRef) { #>
        if (SetProperty(this._<#=FieldName#>, value, (t) => { bool isCancel = false; this.On<#=FieldName#>Changing(<#=refstr#>value, ref isCancel); if (isCancel) return; this._<#=FieldName#> = value; this.On<#=FieldName#>Changed(); })) // <#=t4.FilePos() #>
        {
<#     if (this.DocMes.IsValidatableBase) { #>
            this.ValidateProperty(); // <#=t4.FilePos() #>
<#     } #>
<#     if (this.DocMes.IsEditableBase && IsSimple) { #>
            this.IsChanged = true; // <#=t4.FilePos() #>
<#     } #>
        }
<#   } else { #>
        if (this._<#=FieldName#> != value) // <#=t4.FilePos() #>
        {
            bool isCancel = false;
            this.On<#=FieldName#>Changing(<#=refstr#>value, ref isCancel);
            if (isCancel) return;
            this._<#=FieldName#> = value;
            this.On<#=FieldName#>Changed();
<#     if (this.DocMes.IsValidatableBase) { #>
            this.ValidateProperty(); // <#=t4.FilePos() #>
<#     } #>
<#     if (this.DocMes.IsEditableBase && IsSimple) { #>
            this.IsChanged = true; // <#=t4.FilePos() #>
<#     } #>
        }
<#   } #>
    }
}
<# if (IsNotSkip) { #>
private <#=PropType#> _<#=FieldName#><#=defstr#>; // <#=t4.FilePos() #>
<# } #>
partial void On<#=FieldName#>Changing(<#=refstr#><#=PropType#> to, ref bool isCancel); // <#=t4.FilePos() #>
partial void On<#=FieldName#>Changed();
<# if (this.IsCollection /*this.IsSelfCollection*/) { #>
IReadOnlyList<<#if (!IsSimple) {#>I<#}#><#=FieldType#>> I<#=ClassName#>.<#=FieldName#> { get { return (this as <#=ClassName#>).<#=FieldName#>; } } // <#=t4.FilePos() #>

<#   if (this.IsSelfCollection) { #>
public <#= field.MessageType.Name.ToNameCs() #> this[int index] { get { return (<#= field.MessageType.Name.ToNameCs() #>)this.<#=FieldName#>[index]; } }
I<#= field.MessageType.Name.ToNameCs() #> I<#= message.Name.ToNameCs() #>.this[int index] { get { return (<#= field.MessageType.Name.ToNameCs() #>)this.<#=FieldName#>[index]; } }
public void Add(<#= field.MessageType.Name.ToNameCs() #> item) // <#=t4.FilePos() #>
{ 
    Debug.Assert(item != null);
    this.<#=FieldName#>.Add(item); 
    item.Parent = this;
}
public void AddRange(IEnumerable<<#= field.MessageType.Name.ToNameCs() #>> items) 
{ 
    Debug.Assert(items != null);
    this.<#=FieldName#>.AddRange(items); 
    foreach (var t in items)
        t.Parent = this;
}
public int Count() { return this.<#=FieldName#>.Count; }
int I<#= message.Name.ToNameCs() #>.Count() { return this.Count(); }
public void Remove(<#= field.MessageType.Name.ToNameCs() #> item) 
{
    Debug.Assert(item != null);
    this.<#=FieldName#>.Remove(item); 
    item.Parent = null;
}
<#   } // if (this.IsSelfCollection) #>
<# } if (!this.IsCollection) { #>
<#   if (IsMessage) { #>
I<#=FieldType#> I<#=ClassName#>.<#=FieldName#> { get { return (this as <#=ClassName#>).<#=FieldName#>; } } // <#=t4.FilePos() #>
<#   } #>
<# } #>
<# if (FieldName == "SortingValue") {#>
public void SetSortingValueField(ulong sortValue)
{
    this._SortingValue = sortValue;
}
<# } #>
